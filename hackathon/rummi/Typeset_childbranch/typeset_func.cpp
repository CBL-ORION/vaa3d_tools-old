/* typeset_func.cpp
 * This is a plugin to set segment type based on marker location
 * 2014-06-27 : by Surobhi Ganguly
 */

#include <v3d_interface.h>
#include "v3d_message.h"
#include "typeset_func.h"
#include "typeset.h"
#include "my_surf_objs.h"
#include "customary_structs/vaa3d_neurontoolbox_para.h"
#include <vector>
#include <iostream>
using namespace std;

const QString title = QObject::tr("typeset Neuron");

bool export_list2file(QList<NeuronSWC> & lN, QString fileSaveName, QString FileSWCOpenName)
{
    QFile file(fileSaveName);
    if (!file.open(QIODevice::WriteOnly|QIODevice::Text))
        return false;
    QTextStream myfile(&file);
    myfile<<"# generated by Vaa3D Plugin typeset"<<endl;
    myfile<<"# source file(s): "<<FileSWCOpenName<<endl;
    myfile<<"# id,type,x,y,z,r,pid"<<endl;
    for (V3DLONG i=0;i<lN.size();i++)
        myfile << lN.at(i).n <<" " << lN.at(i).type << " "<< lN.at(i).x <<" "<<lN.at(i).y << " "<< lN.at(i).z << " "<< lN.at(i).r << " " <<lN.at(i).pn << "\n";

    file.close();
    cout<<"swc file "<<fileSaveName.toStdString()<<" has been generated, size: "<<lN.size()<<endl;
    return true;
}

int typeset_swc(V3DPluginCallback2 &callback, QWidget *parent)
{

    QString FileSWCOpenName;
    QString FileMarkerOpenName;

    FileSWCOpenName = QFileDialog::getOpenFileName(0, QObject::tr("Open SWC File"),
            "",
            QObject::tr("Supported file (*.swc *.eswc)"
                ";;Neuron structure	(*.swc)"
                ";;Extended neuron structure (*.eswc)"
                ));

    FileMarkerOpenName = QFileDialog::getOpenFileName(0, QObject::tr("Open Marker File"),
            "",
            QObject::tr("Supported file (*.marker)"));

    if(FileSWCOpenName.isEmpty() || FileMarkerOpenName.isEmpty())
        return 0;

    NeuronTree nt;
    QList<ImageMarker> tmp_list;

    if (FileSWCOpenName.toUpper().endsWith(".SWC") || FileSWCOpenName.toUpper().endsWith(".ESWC"))
    {
        bool ok;

        nt = readSWC_file(FileSWCOpenName);
        if (!ok)
            return 0;
    }

    if (FileMarkerOpenName.toUpper().endsWith(".MARKER"))
    {
        bool ok;
        tmp_list = readMarker_file(FileMarkerOpenName);
        if (!ok)
            return 0;
    }


    //run sort


//    V3DPluginArgItem arg;
//    //V3DPluginArgList input_resample;
//    V3DPluginArgList input_sort;
//    V3DPluginArgList output;

//    arg.type = "random";std::vector<char*> arg_input_sort;
//    std:: string fileName_Qstring(FileSWCOpenName.toStdString());char* fileName_string =  new char[fileName_Qstring.length() + 1]; strcpy(fileName_string, fileName_Qstring.c_str());
//    arg_input_sort.push_back(fileName_string);
//    arg.p = (void *) & arg_input_sort; input_sort<< arg;
//    arg.type = "random";std::vector<char*> arg_sort_para; arg_sort_para.push_back("1");arg.p = ("100") & arg_sort_para; input_sort << arg;
//    arg.type = "random";std::vector<char*> arg_output; arg_output.push_back(fileName_string+QString("_sorted")); arg.p = (void *) & arg_output; output<< arg;

//    //QString full_plugin_name_resample = "resample_swc";
//    //QString func_name_resample = "resample_swc";
//    //callback.callPluginFunc(full_plugin_name_resample,func_name_resample,input_resample,output);

//    arg.type = "random";std::vector<char*> arg_input_sort;
//    arg_input_sort.push_back(fileName_string+QString("_sorted"));
//    arg.p = (void *) & arg_input_sort; input_sort<< arg;
//    arg.type = "random";std::vector<char*> arg_sort_para; arg_sort_para.push_back("1");arg.p = ("100") & arg_sort_para; input_sort << arg;
//    arg.type = "random";std::vector<char*> arg_output; arg_output.push_back(fileName_string+QString("_sorted")); arg.p = (void *) & arg_output; output<< arg;

//    QString full_plugin_name_sort = "sort_neuron_swc";
//    QString func_name_sort = "sort_swc";
//    callback.callPluginFunc(full_plugin_name_sort,func_name_sort, input_sort, output);

//    vector<MyMarker*> temp_out_swc = readSWC_file(FileSWCOpenName.toStdString());
//    saveSWC_file(FileSWCOpenName.toStdString(), temp_out_swc); //, infostring);



    // run typeset

    double settype;
    settype = QInputDialog::getDouble(parent, "Please set child branch type","Type:",0,0,4,1);

    NeuronTree result = typeset(nt, tmp_list, settype);

    QString fileDefaultName = FileSWCOpenName+QString("_")+FileMarkerOpenName+QString("_typeset.swc");
    //write new SWC to file
    QString fileSaveName = QFileDialog::getSaveFileName(0, QObject::tr("Save File"),
            fileDefaultName,
            QObject::tr("Supported file (*.swc)"
                ";;Neuron structure	(*.swc)"
                ));
    if (!export_list2file(result.listNeuron,fileSaveName,FileSWCOpenName))
    {
        v3d_msg("fail to write the output swc file.");
        return 0;
    }


    return 1;
}

bool typeset_swc(const V3DPluginArgList & input, V3DPluginArgList & output)
{
    cout<<"Welcome to typeset_swc"<<endl;
    vector<char*>* inlist = (vector<char*>*)(input.at(0).p);
    vector<char*>* outlist = NULL;
    vector<char*>* paralist = NULL;

    if(input.size() != 2)
    {
        printf("Please specify both input file and segment type.\n");
        return false;
    }
    paralist = (vector<char*>*)(input.at(1).p);
    if (paralist->size()!=1)
    {
        printf("Please specify only one parameter - the resampling step length.\n");
        return false;
    }

    QString FileSWCOpenName = QString(inlist->at(0));
    QString FileMarkerOpenName;
    QString fileSaveName;

    if (output.size()==0)
    {
        printf("No outputfile specified.\n");
        fileSaveName = FileSWCOpenName + "_typesetd.swc";
    }
    else if (output.size()==1)
    {
        outlist = (vector<char*>*)(output.at(0).p);
        fileSaveName = QString(outlist->at(0));
    }
    else
    {
        printf("You have specified more than 1 output file.\n");
        return false;
    }

    NeuronTree nt;
    QList<ImageMarker> tmp_list;

    if (FileSWCOpenName.toUpper().endsWith(".SWC") || FileSWCOpenName.toUpper().endsWith(".ESWC"))
        nt = readSWC_file(FileSWCOpenName);

    double settype = 0;

    if (FileMarkerOpenName.toUpper().endsWith(".marker"))
    {
        bool ok;
        tmp_list = readMarker_file(FileMarkerOpenName);
        if (!ok)
            return 0;
    }

    NeuronTree result = typeset(nt,tmp_list,settype);

    if (!export_list2file(result.listNeuron, fileSaveName, FileSWCOpenName))
    {
        printf("fail to write the output swc file.\n");
        return false;
    }

    return true;
}

bool typeset_swc_toolbox(const V3DPluginArgList & input)
{
    vaa3d_neurontoolbox_paras * paras = (vaa3d_neurontoolbox_paras *)(input.at(0).p);
    NeuronTree nt = paras->nt;
    QString FileSWCOpenName = nt.file;
    QString FileMarkerOpenName;


    bool ok;
    double settype = 0;
    QList<ImageMarker> tmp_list;
    tmp_list = readMarker_file(FileMarkerOpenName);

    if (!ok)
        return true;

    NeuronTree result = typeset(nt,tmp_list,settype);

    QString fileDefaultName = FileSWCOpenName+QString("_")+FileMarkerOpenName+QString("_typeset.swc");
    //write new SWC to file
    QString fileSaveName = QFileDialog::getSaveFileName(0, QObject::tr("Save File"),
            fileDefaultName,
            QObject::tr("Supported file (*.swc)"
                ";;Neuron structure	(*.swc)"
                ));
    if (!export_list2file(result.listNeuron,fileSaveName,FileSWCOpenName))
    {
        v3d_msg("fail to write the output swc file.");
        return false;
    }

    return true;

}

