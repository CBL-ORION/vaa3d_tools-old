/* typeset_func.cpp
 * This is a plugin to set segment type based on marker location
 * 2014-06-27 : by Surobhi Ganguly
 */

#include <v3d_interface.h>
#include "v3d_message.h"
#include "my_surf_objs.h"
#include "openSWCDialog.h"
#include "typeset.h"
#include "typeset_func.h"
#include "typeset_plugin.h"
#include "customary_structs/vaa3d_neurontoolbox_para.h"
#include <vector>
#include <iostream>
//using namespace std;

//const QString title = QObject::tr("typeset Neuron");

static LandmarkList current_3Dview_markers;

bool export_list2file_v2(QList<NeuronSWC> & lN, QString fileSaveName, QString FileSWCOpenName)
{
    QFile file(fileSaveName);
    if (!file.open(QIODevice::WriteOnly|QIODevice::Text))
        return false;
    QTextStream myfile(&file);
    myfile<<"# generated by Vaa3D Plugin typeset"<<endl;
    myfile<<"# source file(s): "<<FileSWCOpenName<<endl;
    myfile<<"# id,type,x,y,z,r,pid"<<endl;
    for (V3DLONG i=0;i<lN.size();i++)
        myfile << lN.at(i).n <<" " << lN.at(i).type << " "<< lN.at(i).x <<" "<<lN.at(i).y << " "<< lN.at(i).z << " "<< lN.at(i).r << " " <<lN.at(i).pn << "\n";
    file.close();
    cout<<"swc file "<<fileSaveName.toStdString()<<" has been generated, size: "<<lN.size()<<endl;
    return true;
}

static int file_count = 0;

int typeset_swc_func(V3DPluginCallback2 &callback, double settype)
{
    v3d_msg("Be sure to open the correct the sorted swc file");


    //if an swc file is open already, then use that, if more than one or zero open, call following

    //v3dhandleList open_files = callback.getImageWindowList();
    //int open_files_num = open_files.size();
    QString FileSWCOpenName;
    NeuronTree nt;


//    if (open_files_num == 1)
//    {
//        v3dhandle current_3Dview = callback.currentImageWindow();
//        FileSWCOpenName = callback.getImageName(current_3Dview);
//        nt = callback.getSWC(current_3Dview);

//    }
//    else if (open_files_num == 0 || open_files_num > 1)
//    {

        OpenSWCDialog * openDlg = new OpenSWCDialog(0, &callback);
        if (!openDlg->exec())
            return 0;

        FileSWCOpenName = openDlg->file_name;

        nt = openDlg->nt;
//    }

//    QList<NeuronSWC> neuron = nt.listNeuron;

//    QString FileSWCOpenName;
//    FileSWCOpenName = QFileDialog::getOpenFileName(0, QObject::tr("Open Sorted SWC File"),
//            "",
//            QObject::tr("Supported file (*.swc *.eswc)"
//                ";;Neuron structure	(*.swc)"
//                ";;Extended neuron structure (*.eswc)"
//                ));

//    NeuronTree nt;

//    if (FileSWCOpenName.toUpper().endsWith(".SWC") || FileSWCOpenName.toUpper().endsWith(".ESWC"))
//    {
//        bool ok;

//        nt = readSWC_file(FileSWCOpenName);
//        if (!ok)
//            return 0;
//    }

    QList<ImageMarker> tmp_list;
    NeuronTree result = nt;

    tmp_list = get_markers(callback);

    if (tmp_list.size() < 1)
    {
        v3d_msg("no markers in 3D window; plugin not run");
        return 0;
    }
    else
    {
        //double settype; //get settype from private void in plugin.cpp
        //settype = QInputDialog::getDouble(parent, "Please set child branch type","Type:",0,0,4,1);
        //settype = QInputDialog::getDouble(0, "Please set child branch type","Type:",0,0,4,1);

        result = typeset_marker(nt, tmp_list, settype);

        QString fileDefaultName = FileSWCOpenName+QString("_%1_typeset.swc").arg(file_count);
        //write new SWC to file
        QString fileSaveName = QFileDialog::getSaveFileName(0, QObject::tr("Save File"),
                fileDefaultName,
                QObject::tr("Supported file (*.swc)"
                    ";;Neuron structure	(*.swc)"
                    ));
        if (!export_list2file_v2(result.listNeuron,fileSaveName,FileSWCOpenName))
        {
            v3d_msg("fail to write the output swc file.");
            return 0;
        }
        return 1;
    }
    file_count++;
}

QList<ImageMarker> get_markers(V3DPluginCallback2 &callback)
{
    v3dhandle current_3Dview = callback.currentImageWindow(); //get's current image window (3D that's open)
    current_3Dview_markers = callback.getLandmark(current_3Dview); //gives list of markers drawn

    QList<ImageMarker> tmp_list;

    for (V3DLONG i=0;i<current_3Dview_markers.size();i++)//translate marker info from landmark list to tmp_list
    {
        LocationSimple t = current_3Dview_markers.at(i);

        ImageMarker pt;
        pt.n = i+1; //marker number
        pt.x = t.x;
        pt.y = t.y;
        pt.z = t.z;
        tmp_list.push_back(pt);
    }

    return tmp_list;
}



//QList<ImageMarker> delete_markers(V3DPluginCallback2 &callback, ImageMarker coordinate)
//{

//    v3dhandle current_3Dview = callback.currentImageWindow();
//    current_3Dview_markers = callback.getLandmark(current_3Dview);

//   // i guess i'll need this eventually (or something along these lines): callback.update_3DViewer(current_3Dview);

//    QList<LocationSimple> markers_3Dview_update;

//    for (V3DLONG i=0;i<current_3Dview_markers.size();i++)//translate marker info from landmark list to tmp_list
//    {
//        LocationSimple t = current_3Dview_markers.at(i);

//        LocationSimple pt;
//        pt.n = i+1; //marker number
//        pt.x = t.x;
//        pt.y = t.y;
//        pt.z = t.z;
//        markers_3Dview_update.push_back(pt);
//    }



//    QList<ImageMarker> tmp_list = get_markers(callback);
//    QList<ImageMarker> tmp_list_new;

//    for (V3DLONG i=0; i<tmp_list.size(); i++)
//    {
//        if(coordinate.x != tmp_list.x && coordinate.y != tmp_list.y && coordinate.z != tmp_list.z)
//        {
//            tmp_list_new.push_back(tmp_list.at(i)); //if the coordinates don't match, then it adds it to the new list and reloads it. i guess. so kind of like the refresh button.
//        }
//    }


//    //blarp
//}

bool typeset_swc(const V3DPluginArgList & input, V3DPluginArgList & output)
{
    cout<<"Welcome to typeset_swc"<<endl;
    vector<char*>* inlist = (vector<char*>*)(input.at(0).p);
    vector<char*>* outlist = NULL;
    vector<char*>* paralist = NULL;

    if(input.size() != 2)
    {
        printf("Please specify both input file and segment type.\n");
        return false;
    }
    paralist = (vector<char*>*)(input.at(1).p);
    if (paralist->size()!=1)
    {
        printf("Please specify only one parameter - the resampling step length.\n");
        return false;
    }

    QString FileSWCOpenName = QString(inlist->at(0));
    QString FileMarkerOpenName;
    QString fileSaveName;

    if (output.size()==0)
    {
        printf("No outputfile specified.\n");
        fileSaveName = FileSWCOpenName + "_typeset.swc";
    }
    else if (output.size()==1)
    {
        outlist = (vector<char*>*)(output.at(0).p);
        fileSaveName = QString(outlist->at(0));
    }
    else
    {
        printf("You have specified more than 1 output file.\n");
        return false;
    }

    NeuronTree nt;
    QList<ImageMarker> tmp_list;

    if (FileSWCOpenName.toUpper().endsWith(".SWC") || FileSWCOpenName.toUpper().endsWith(".ESWC"))
        nt = readSWC_file(FileSWCOpenName);

    double settype = 0;

    if (FileMarkerOpenName.toUpper().endsWith(".marker"))
    {
        bool ok;
        tmp_list = readMarker_file(FileMarkerOpenName);
        if (!ok)
            return 0;
    }

    NeuronTree result = typeset_marker(nt,tmp_list,settype);

    if (!export_list2file_v2(result.listNeuron, fileSaveName, FileSWCOpenName))
    {
        printf("fail to write the output swc file.\n");
        return false;
    }

    return true;
}

bool typeset_swc_toolbox(const V3DPluginArgList & input)
{
    vaa3d_neurontoolbox_paras * paras = (vaa3d_neurontoolbox_paras *)(input.at(0).p);
    NeuronTree nt = paras->nt;
    QString FileSWCOpenName = nt.file;
    QString FileMarkerOpenName;


    bool ok;
    double settype = 0;
    QList<ImageMarker> tmp_list;
    tmp_list = readMarker_file(FileMarkerOpenName);

    if (!ok)
        return true;

    NeuronTree result = typeset_marker(nt,tmp_list,settype);

    QString fileDefaultName = FileSWCOpenName+QString("_")+FileMarkerOpenName+QString("_typeset.swc");
    //write new SWC to file
    QString fileSaveName = QFileDialog::getSaveFileName(0, QObject::tr("Save File"),
            fileDefaultName,
            QObject::tr("Supported file (*.swc)"
                ";;Neuron structure	(*.swc)"
                ));
    if (!export_list2file_v2(result.listNeuron,fileSaveName,FileSWCOpenName))
    {
        v3d_msg("fail to write the output swc file.");
        return false;
    }

    return true;

}
