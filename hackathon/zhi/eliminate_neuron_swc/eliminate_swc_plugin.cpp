/* eliminate_swc_plugin.cpp
 * This plugin is used to eliminate small segments in swc file
 * 2013-12-16 : by Zhi Zhou
 */
 
#include "v3d_message.h"
#include <vector>
#include "eliminate_swc_plugin.h"
#include "basic_surf_objs.h"
#include <iostream>
#include "../../../released_plugins/v3d_plugins/istitch/y_imglib.h"
#include "my_surf_objs.h"

using namespace std;

#define getParent(n,nt) ((nt).listNeuron.at(n).pn<0)?(1000000000):((nt).hashNeuron.value((nt).listNeuron.at(n).pn))

// Open a series of inputs
QStringList importSeriesFileList_addnumbersort(const QString & curFilePath)
{
    QStringList myList;
    myList.clear();

    // get the image files namelist in the directory
    QStringList imgSuffix;
    imgSuffix<<"*.tif"<<"*.raw"<<"*.v3draw"<<"*.lsm"
            <<"*.TIF"<<"*.RAW"<<"*.V3DRAW"<<"*.LSM";

    QDir dir(curFilePath);
    if (!dir.exists())
    {
        qWarning("Cannot find the directory");
        return myList;
    }

    foreach (QString file, dir.entryList(imgSuffix, QDir::Files, QDir::Name))
    {
        myList += QFileInfo(dir, file).absoluteFilePath();
    }

    // print filenames
    foreach (QString qs, myList)  qDebug() << qs;

    return myList;
}

Q_EXPORT_PLUGIN2(eliminate_swc, eliminate_swc);
 
QStringList eliminate_swc::menulist() const
{
	return QStringList() 
        <<tr("eliminate_swc")
        <<tr("combine_swc_tc")
        <<tr("combine_swc_pair")
        <<tr("prun_swc")
        <<tr("z_section to tiles")
		<<tr("about");
}

QStringList eliminate_swc::funclist() const
{
	return QStringList()
		<<tr("func1")
		<<tr("help");
}

NeuronTree eliminate(NeuronTree input, double length);
NeuronTree eliminate_overlap(NeuronTree target, NeuronTree subject, double length);
void combineSWC_tc(V3DPluginCallback2 &callback, QWidget *parent);
void combineSWC_pair(V3DPluginCallback2 &callback, QWidget *parent);
void prunSWC(V3DPluginCallback2 &callback, QWidget *parent);
void zsectionsTotiles(V3DPluginCallback2 &callback, QWidget *parent);


struct Point;
struct Point
{
    double x,y,z,r;
    V3DLONG type;
    Point* p;
    V3DLONG childNum;
};

typedef vector<Point*> Segment;
typedef vector<Point*> Tree;

void extend_path(Segment * seg);
bool export_list2file(QList<NeuronSWC> & lN, QString fileSaveName, QString fileOpenName)
{
    QFile file(fileSaveName);
    if (!file.open(QIODevice::WriteOnly|QIODevice::Text))
        return false;
    QTextStream myfile(&file);
    myfile<<"# generated by Vaa3D Plugin eliminate_swc"<<endl;
    myfile<<"# source file(s): "<<fileOpenName<<endl;
    myfile<<"# id,type,x,y,z,r,pid"<<endl;
    for (V3DLONG i=0;i<lN.size();i++)
        myfile << lN.at(i).n <<" " << lN.at(i).type << " "<< lN.at(i).x <<" "<<lN.at(i).y << " "<< lN.at(i).z << " "<< lN.at(i).r << " " <<lN.at(i).pn << "\n";

    file.close();
    cout<<"swc file "<<fileSaveName.toStdString()<<" has been generated, size: "<<lN.size()<<endl;
    return true;
};


void eliminate_swc::domenu(const QString &menu_name, V3DPluginCallback2 &callback, QWidget *parent)
{
    if (menu_name == tr("eliminate_swc"))
	{
        QString fileOpenName;
        fileOpenName = QFileDialog::getOpenFileName(0, QObject::tr("Open File"),
                "",
                QObject::tr("Supported file (*.swc *.eswc)"
                    ";;Neuron structure	(*.swc)"
                    ";;Extended neuron structure (*.eswc)"
                    ));
        if(fileOpenName.isEmpty())
            return;
        double length = 0;
        NeuronTree nt;
        if (fileOpenName.toUpper().endsWith(".SWC") || fileOpenName.toUpper().endsWith(".ESWC"))
        {
            bool ok;
            nt = readSWC_file(fileOpenName);
            length = QInputDialog::getDouble(parent, "Please specify the minimum segment length","segment length:",1,0,2147483647,0.1,&ok);
            if (!ok)
                return;
        }

        NeuronTree result = eliminate(nt, length);

        QString fileDefaultName = fileOpenName+QString("thresholded.swc");
        //write new SWC to file
        QString fileSaveName = QFileDialog::getSaveFileName(0, QObject::tr("Save File"),
                fileDefaultName,
                QObject::tr("Supported file (*.swc)"
                    ";;Neuron structure	(*.swc)"
                    ));
        if (!export_list2file(result.listNeuron,fileSaveName,fileOpenName))
        {
            v3d_msg("fail to write the output swc file.");
            return;
        }


	}
    else if(menu_name == tr("combine_swc_tc"))
    {
         combineSWC_tc(callback, parent);
    }
    else if(menu_name == tr("combine_swc_pair"))
    {
        combineSWC_pair(callback, parent);

    }
    else if(menu_name == tr("prun_swc"))
    {
        prunSWC(callback, parent);

    }
    else if(menu_name == tr("z_section to tiles"))
    {
        zsectionsTotiles(callback,parent);
    }
    else
	{
		v3d_msg(tr("This plugin is used to eliminate small segments in swc file. "
			"Developed by Zhi Zhou, 2013-12-16"));
	}
}

bool eliminate_swc::dofunc(const QString & func_name, const V3DPluginArgList & input, V3DPluginArgList & output, V3DPluginCallback2 & callback,  QWidget * parent)
{
	vector<char*> infiles, inparas, outfiles;
	if(input.size() >= 1) infiles = *((vector<char*> *)input.at(0).p);
	if(input.size() >= 2) inparas = *((vector<char*> *)input.at(1).p);
	if(output.size() >= 1) outfiles = *((vector<char*> *)output.at(0).p);

	if (func_name == tr("func1"))
	{
		v3d_msg("To be implemented.");
	}
	else if (func_name == tr("help"))
	{
		v3d_msg("To be implemented.");
	}
	else return false;

	return true;
}

NeuronTree eliminate(NeuronTree input, double length)
{
    NeuronTree result;
    V3DLONG siz = input.listNeuron.size();
    Tree tree;
    for (V3DLONG i=0;i<siz;i++)
    {
        NeuronSWC s = input.listNeuron[i];
        Point* pt = new Point;
        pt->x = s.x;
        pt->y = s.y;
        pt->z = s.z;
        pt->r = s.r;
        pt ->type = s.type;
        pt->p = NULL;
        pt->childNum = 0;
        tree.push_back(pt);
    }
    for (V3DLONG i=0;i<siz;i++)
    {
        if (input.listNeuron[i].pn<0) continue;
        V3DLONG pid = input.hashNeuron.value(input.listNeuron[i].pn);
        tree[i]->p = tree[pid];
        tree[pid]->childNum++;
    }
//	printf("tree constructed.\n");
    vector<Segment*> seg_list;
    for (V3DLONG i=0;i<siz;i++)
    {
        if (tree[i]->childNum!=1)//tip or branch point
        {
            Segment* seg = new Segment;
            Point* cur = tree[i];
            do
            {
                seg->push_back(cur);
                cur = cur->p;
            }
            while(cur && cur->childNum==1);
            seg_list.push_back(seg);
        }
    }
//	printf("segment list constructed.\n");
  /*  for (V3DLONG i=0;i<seg_list.size();i++)
    {
        if(seg_list[i]->size() > length)
            extend_path(seg_list[i]);
    }*/

//	printf("resample done.\n");
    tree.clear();
    map<Point*, V3DLONG> index_map;
    for (V3DLONG i=0;i<seg_list.size();i++)
    {
        //double space_distace = sqrt(pow(seg_list[i]->at(0)-seg_list[i]->at((seg_list[i]->size())),2.0));
        if(seg_list[i]->size()>length)// || space_distace > length)
        {
            for (V3DLONG j=0;j<seg_list[i]->size();j++)
            {
                tree.push_back(seg_list[i]->at(j));
                index_map.insert(pair<Point*, V3DLONG>(seg_list[i]->at(j), tree.size()-1));
            }
        }
    }
    for (V3DLONG i=0;i<tree.size();i++)
    {
        NeuronSWC S;
        Point* p = tree[i];
        S.n = i+1;
        if (p->p==NULL || index_map[p->p] ==0) S.pn = -1;
        else
            S.pn = index_map[p->p]+1;
        if (p->p==p) printf("There is loop in the tree!\n");
        S.x = p->x;
        S.y = p->y;
        S.z = p->z;
        S.r = p->r;
        S.type = p->type;
        result.listNeuron.push_back(S);
    }
    for (V3DLONG i=0;i<tree.size();i++)
    {
        if (tree[i]) {delete tree[i]; tree[i]=NULL;}
    }
    for (V3DLONG j=0;j<seg_list.size();j++)
        if (seg_list[j]) {delete seg_list[j]; seg_list[j] = NULL;}
    for (V3DLONG i=0;i<result.listNeuron.size();i++)
    {
        result.hashNeuron.insert(result.listNeuron[i].n, i);
    }
    return result;
}

void extend_path(Segment * seg)
{

    Point* last_pt = seg->at(0);
    Point* last_pt2 = seg->at(1);
    Segment seg_r = *seg;
    if(last_pt->z > 45.0)
    {
        for(int i = 0; i <200;i++)
        {
           Point* pt = new Point;;
           pt->x = 2*last_pt->x - last_pt2->x;
           pt->y = 2*last_pt->y - last_pt2->y;
           pt->z = 2*last_pt->z - last_pt2->z;
           pt ->type = 3;
           pt->p = last_pt;
           pt->r = last_pt->r;
           seg_r.push_back(pt);
           last_pt2 = last_pt;
           last_pt = pt;
        }
        printf("end point is %.2f\n",last_pt->z);
    }
    *seg = seg_r;
}

void combineSWC_tc(V3DPluginCallback2 &callback, QWidget *parent)
{

    QString foldername = QFileDialog::getExistingDirectory(parent, "Open Directory",
                                      QDir::currentPath(),
                                      QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

    QDir myDir(foldername);
    QStringList list = myDir.entryList(QStringList("*.tc"));

    if(list.size()!=1)
    {
        printf("Must have only one stitching configuration file!\n");
        return;
    }

    // load config
    Y_VIM<REAL, V3DLONG, indexed_t<V3DLONG, REAL>, LUT<V3DLONG> > vim;

    QString tcfile = QString(foldername).append("/").append(list.at(0));

    if( !vim.y_load(tcfile.toStdString()) )
    {
        printf("Wrong stitching configuration file to be load!\n");
        return;
    }

    vector<MyMarker*> outswc;
    for(V3DLONG ii=0; ii<vim.number_tiles; ii++)
    {
        try
        {
        QString curPath = QFileInfo(tcfile).path();;
        QString curPathSWC = curPath.append("/").append(QString(vim.lut[ii].fn_img.c_str())).append("_neutube.swc");

        V3DLONG jx_s, jy_s, jz_s, jx_e, jy_e, jz_e;
        jx_s = vim.lut[ii].start_pos[0];
        jy_s = vim.lut[ii].start_pos[1];
        jz_s = vim.lut[ii].start_pos[2];

        jx_e = vim.lut[ii].end_pos[0];
        jy_e = vim.lut[ii].end_pos[1];
        jz_e = vim.lut[ii].end_pos[2];
        vector<MyMarker*> inputswc = readSWC_file(curPathSWC.toStdString());;

        for(V3DLONG d = 0; d < inputswc.size(); d++)
        {
            inputswc[d]->x =  inputswc[d]->x + jx_s;
            inputswc[d]->y =  inputswc[d]->y + jy_s;

            outswc.push_back(inputswc[d]);
        }
        }
        catch (...)
        {

        };


       // break;

    }
    saveSWC_file("/opt/zhi/Desktop/test.swc", outswc);





}

void combineSWC_pair(V3DPluginCallback2 &callback, QWidget *parent)
{
    QString targetname;
    targetname = QFileDialog::getOpenFileName(0, QObject::tr("Open Target File"),
            "",
            QObject::tr("Supported file (*.swc *.eswc)"
                ";;Neuron structure	(*.swc)"
                ";;Extended neuron structure (*.eswc)"
                ));
    if(targetname.isEmpty())
        return;
    NeuronTree nt_target;
    if (targetname.toUpper().endsWith(".SWC") || targetname.toUpper().endsWith(".ESWC"))
    {
        nt_target = readSWC_file(targetname);

    }

    QString subjectname;
    subjectname = QFileDialog::getOpenFileName(0, QObject::tr("Open Subject File"),
            "",
            QObject::tr("Supported file (*.swc *.eswc)"
                ";;Neuron structure	(*.swc)"
                ";;Extended neuron structure (*.eswc)"
                ));
    if(subjectname.isEmpty())
        return;
    NeuronTree nt_subject;
    if (subjectname.toUpper().endsWith(".SWC") || subjectname.toUpper().endsWith(".ESWC"))
    {
        nt_subject = readSWC_file(subjectname);
    }

  //  NeuronTree result = eliminate_overlap(nt_target,nt_subject,5.0);
    NeuronTree result = nt_subject;
    V3DLONG target_size = nt_target.listNeuron.size();
    for(V3DLONG i = 0; i < result.listNeuron.size();i++)
    {
        //V3DLONG target_size = nt_target.listNeuron.size();

        NeuronSWC S = result.listNeuron[i];
        if(S.parent >0) S.parent = S.parent + target_size;
        S.n = S.n + target_size;
        nt_target.listNeuron.push_back(S);

     /*   int flag_prun = 0;
        for(int jj = 0; jj < nt_target.listNeuron.size();jj++)
        {
             NeuronSWC S2 = nt_target.listNeuron[jj];
            int dis_prun = sqrt(pow(S.x - S2.x,2) + pow(S.y - S2.y,2) + pow(S.z-S2.z,2));
            if( dis_prun < 10)
            {
                flag_prun = 1;
                break;
            }

        }
        if(flag_prun == 0)
        {
           // S.parent = -1;//S.parent + target_size;
           // S.n = S.n + target_size;
            S.parent = -1;
            S.n = S.n + target_size;
            nt_target.listNeuron.push_back(S);
        }*/

    }

    QString fileDefaultName = targetname+QString("_combined.swc");
    //write new SWC to file
    QString fileSaveName = QFileDialog::getSaveFileName(0, QObject::tr("Save File"),
            fileDefaultName,
            QObject::tr("Supported file (*.swc)"
                ";;Neuron structure	(*.swc)"
                ));
    if (!export_list2file(nt_target.listNeuron,fileSaveName,fileDefaultName))
    {
        v3d_msg("fail to write the output swc file.");
        return;
    }

}

NeuronTree eliminate_overlap(NeuronTree target_swc, NeuronTree subject_swc, double length)
{
    NeuronTree result;
    V3DLONG siz = subject_swc.listNeuron.size();
    Tree tree;
    for (V3DLONG i=0;i<siz;i++)
    {
        NeuronSWC s = subject_swc.listNeuron[i];
        Point* pt = new Point;
        pt->x = s.x;
        pt->y = s.y;
        pt->z = s.z;
        pt->r = s.r;
        pt ->type = s.type;
        pt->p = NULL;
        pt->childNum = 0;
        tree.push_back(pt);
    }
    for (V3DLONG i=0;i<siz;i++)
    {
        if (subject_swc.listNeuron[i].pn<0) continue;
        V3DLONG pid = subject_swc.hashNeuron.value(subject_swc.listNeuron[i].pn);
        tree[i]->p = tree[pid];
        tree[pid]->childNum++;
    }
//	printf("tree constructed.\n");
    vector<Segment*> seg_list;
    for (V3DLONG i=0;i<siz;i++)
    {
        if (tree[i]->childNum!=1)//tip or branch point
        {
            Segment* seg = new Segment;
            Point* cur = tree[i];
            do
            {
                seg->push_back(cur);
                cur = cur->p;
            }
            while(cur && cur->childNum==1);
            seg_list.push_back(seg);
        }
    }
    tree.clear();
    map<Point*, V3DLONG> index_map;

    V3DLONG sz[4];
    sz[0] = 4080/3;
    sz[1] = 13297/3;
    sz[2] = 210/3;
    V3DLONG pagesz = sz[0]*sz[1]*sz[2];

    char *target_map = new char[pagesz];
    if(!target_map) return result;
    for(V3DLONG i =0; i < pagesz; i++) target_map[i] = 0;
    for(V3DLONG i = 0; i <target_swc.listNeuron.size();i++)
    {

        NeuronSWC S = target_swc.listNeuron[i];
        V3DLONG dz = (int)(S.z/length);
        V3DLONG dy = (int)(S.y/length);
        V3DLONG dx = (int)(S.x/length);
        target_map[dz*sz[0]*sz[1] + dy*sz[0] + dx] = 1;
    }


    for (V3DLONG i=0;i<seg_list.size();i++)
    {

        bool flag = 1;
        for (V3DLONG j=0;j<seg_list[i]->size();j++)
        {
            Point* node = seg_list[i]->at(j);
            V3DLONG dz = (int)(node->z/length);
            V3DLONG dy = (int)(node->y/length);
            V3DLONG dx = (int)(node->x/length);

            if(target_map[dz*sz[0]*sz[1] + dy*sz[0] + dx] ==1)
            {
               flag = 0;
               break;
            }
        }
        if(flag)
        {
            for (V3DLONG j=0;j<seg_list[i]->size();j++)
            {
                tree.push_back(seg_list[i]->at(j));
                index_map.insert(pair<Point*, V3DLONG>(seg_list[i]->at(j), tree.size()-1));
            }
        }
    }

    if(target_map) {delete target_map; target_map = 0;}
    for (V3DLONG i=0;i<tree.size();i++)
    {
        NeuronSWC S;
        Point* p = tree[i];
        S.n = i+1;
        if (p->p==NULL || index_map[p->p] ==0) S.pn = -1;
        else
            S.pn = index_map[p->p]+1;
        if (p->p==p) printf("There is loop in the tree!\n");
        S.x = p->x;
        S.y = p->y;
        S.z = p->z;
        S.r = p->r;
        S.type = p->type;
        result.listNeuron.push_back(S);
    }
    for (V3DLONG i=0;i<tree.size();i++)
    {
        if (tree[i]) {delete tree[i]; tree[i]=NULL;}
    }
    for (V3DLONG j=0;j<seg_list.size();j++)
        if (seg_list[j]) {delete seg_list[j]; seg_list[j] = NULL;}
    for (V3DLONG i=0;i<result.listNeuron.size();i++)
    {
        result.hashNeuron.insert(result.listNeuron[i].n, i);
    }
    return result;




}

void prunSWC(V3DPluginCallback2 &callback, QWidget *parent)
{
    QString fileOpenName;
    fileOpenName = QFileDialog::getOpenFileName(0, QObject::tr("Open File"),
            "",
            QObject::tr("Supported file (*.swc *.eswc)"
                ";;Neuron structure	(*.swc)"
                ";;Extended neuron structure (*.eswc)"
                ));
    if(fileOpenName.isEmpty())
        return;
    double length = 0;
    NeuronTree nt;
    if (fileOpenName.toUpper().endsWith(".SWC") || fileOpenName.toUpper().endsWith(".ESWC"))
    {
        bool ok;
        nt = readSWC_file(fileOpenName);
        length = QInputDialog::getDouble(parent, "Please specify the minimum segment length","segment length:",1,0,2147483647,0.1,&ok);
        if (!ok)
            return;
    }

    QVector<QVector<V3DLONG> > childs;


    V3DLONG neuronNum = nt.listNeuron.size();
    childs = QVector< QVector<V3DLONG> >(neuronNum, QVector<V3DLONG>() );

    for (V3DLONG i=0;i<neuronNum;i++)
    {
        V3DLONG par = nt.listNeuron[i].pn;
        if (par<0) continue;
        childs[nt.hashNeuron.value(par)].push_back(i);
    }


    V3DLONG *AAA = new V3DLONG[neuronNum];
    for (V3DLONG i=0;i<neuronNum;i++)
    {
        AAA[i] = 1;
    }

    QList<NeuronSWC> list = nt.listNeuron;
   for (int i=0;i<list.size();i++)
    {


        if (childs[i].size()==0)
        {
            int index_tip = 0;
            int parent_tip = getParent(i,nt);
            while(childs[parent_tip].size()<2)
            {

                parent_tip = getParent(parent_tip,nt);
                index_tip++;
            }
            if(index_tip < length)
            {
                AAA[i] = -1;

                int parent_tip = getParent(i,nt);
                while(childs[parent_tip].size()<2)
                {
                    AAA[parent_tip] = -1;

                    parent_tip = getParent(parent_tip,nt);
                }
            }

        }

    }

   //NeutronTree structure
   NeuronTree marker_MST;
   QList <NeuronSWC> listNeuron;
   QHash <int, int>  hashNeuron;
   listNeuron.clear();
   hashNeuron.clear();

   //set node

   NeuronSWC S;
   listNeuron.append(S);
   hashNeuron.insert(S.n, listNeuron.size()-1);


   for (int i=0;i<list.size();i++)
   {
       if(AAA[i] == 1)
       {
            NeuronSWC curr = list.at(i);
            S.n 	= curr.n;
            S.type 	= curr.type;
            S.x 	= curr.x;
            S.y 	= curr.y;
            S.z 	= curr.z;
            S.r 	= curr.r;
            S.pn 	= curr.pn;
            listNeuron.append(S);
            hashNeuron.insert(S.n, listNeuron.size()-1);
       }

  }
   marker_MST.n = -1;
   marker_MST.on = true;
   marker_MST.listNeuron = listNeuron;
   marker_MST.hashNeuron = hashNeuron;

   QString outfilename = "tips.swc";

   writeSWC_file(outfilename,marker_MST);
}

void zsectionsTotiles(V3DPluginCallback2 &callback, QWidget *parent)
{
    QString m_InputfolderName = QFileDialog::getExistingDirectory(parent, QObject::tr("Choose the directory including all images "),
                                          QDir::currentPath(),
                                          QFileDialog::ShowDirsOnly);

    QString m_OutputfolderName = QFileDialog::getExistingDirectory(parent, QObject::tr("Choose the directory to save all tiles "),
                                          QDir::currentPath(),
                                          QFileDialog::ShowDirsOnly);

    QStringList imgList = importSeriesFileList_addnumbersort(m_InputfolderName);

    Y_VIM<REAL, V3DLONG, indexed_t<V3DLONG, REAL>, LUT<V3DLONG> > vim;

    V3DLONG count=0;
    foreach (QString img_str, imgList)
    {
        V3DLONG offset[3];
        offset[0]=0; offset[1]=0; offset[2]=0;

        indexed_t<V3DLONG, REAL> idx_t(offset);

        idx_t.n = count;
        idx_t.ref_n = 0; // init with default values
        idx_t.fn_image = img_str.toStdString();
        idx_t.score = 0;

        vim.tilesList.push_back(idx_t);
        count++;
    }

    int NTILES  = vim.tilesList.size();

    unsigned char * data1d = 0;
    V3DLONG in_sz[4];
    int datatype;

    if (!simple_loadimage_wrapper(callback,const_cast<char *>(vim.tilesList.at(0).fn_image.c_str()), data1d, in_sz, datatype))
    {
        fprintf (stderr, "Error happens in reading the subject file [%0]. Exit. \n",vim.tilesList.at(0).fn_image.c_str());
        return;
    }

    int Ws = 1024;
    V3DLONG N = in_sz[0];
    V3DLONG M = in_sz[1];
    V3DLONG P = NTILES;
    V3DLONG pagesz = N*M*1;

    if(data1d) {delete []data1d; data1d=0;}

    for(V3DLONG iz = 0; iz < NTILES; iz = iz + 100)
    {
        V3DLONG zb = iz;
        V3DLONG ze = iz + 100 - 1; if(ze>=NTILES-1) ze = NTILES-1;

        unsigned char *sub_image=0;
        V3DLONG sub_image_sz = N*M*(ze-zb+1);
        sub_image = new unsigned char [sub_image_sz];
        for(V3DLONG i = 0; i < sub_image_sz; i++)
            sub_image[i] = 0;

        V3DLONG j = 0;
        for(int ii = zb; ii < ze + 1; ii++)
        {
            unsigned char * data1d = 0;
            V3DLONG in_sz[4];
            int datatype;

            if (!simple_loadimage_wrapper(callback,const_cast<char *>(vim.tilesList.at(ii).fn_image.c_str()), data1d, in_sz, datatype))
            {
                fprintf (stderr, "Error happens in reading the subject file [%0]. Exit. \n",vim.tilesList.at(ii).fn_image.c_str());
                return;
            }

            for(V3DLONG i = 0; i < pagesz; i++)
            {
                sub_image[j] = data1d[i];
                j++;
            }
            if(data1d) {delete []data1d; data1d=0;}

        }

        for(V3DLONG iy = 0; iy < M; iy = iy+Ws-Ws/10)
        {
            V3DLONG yb = iy;
            V3DLONG ye = iy+Ws-1; if(ye>=M-1) ye = M-1;

            for(V3DLONG ix = 0; ix < N; ix = ix+Ws-Ws/10)
            {
                V3DLONG xb = ix;
                V3DLONG xe = ix+Ws-1; if(xe>=N-1) xe = N-1;

                unsigned char *blockarea=0;
                V3DLONG blockpagesz = (xe-xb+1)*(ye-yb+1)*(ze-zb+1);
                blockarea = new unsigned char [blockpagesz];
                for(V3DLONG i = 0; i < blockpagesz; i++)
                    blockarea[i] = 0;

                V3DLONG i = 0;
                for(V3DLONG iz = 0; iz < ze-zb+1; iz++)
                {
                    V3DLONG offsetk = iz*M*N;
                    for(V3DLONG iy = yb; iy < ye+1; iy++)
                    {
                        V3DLONG offsetj = iy*N;
                        for(V3DLONG ix = xb; ix < xe+1; ix++)
                        {

                            blockarea[i] = sub_image[offsetk + offsetj + ix];
                            i++;
                        }
                    }
                }

                V3DLONG block_sz[4];
                block_sz[0] = xe-xb+1; block_sz[1] = ye-yb+1; block_sz[2] = (ze-zb+1); block_sz[3] = 1;



                QString outputTile(m_OutputfolderName);
                outputTile.append(QString("/x_%1_%2_y_%3_%4_z_%5_%6.raw").arg(xb).arg(xe).arg(yb).arg(ye).arg(zb).arg(ze));
                simple_saveimage_wrapper(callback, outputTile.toStdString().c_str(), (unsigned char *)blockarea, block_sz, 1);
                if(blockarea) {delete []blockarea; blockarea=0;}

            }
        }

        if(sub_image) {delete []sub_image; sub_image=0;}


    }

    V3DLONG tilenum = (floor(N/(0.9*Ws))+1.0)*(floor(M/(0.9*Ws))+1.0);
    QString tc_name(m_OutputfolderName);
    tc_name.append("/stitched_image.tc");

    ofstream myfile;
    myfile.open (tc_name.toStdString().c_str(),ios::out | ios::app );
    myfile << "# thumbnail file \n";
    myfile << "NULL \n\n";
    myfile << "# tiles \n";
    myfile << tilenum << " \n\n";
    myfile << "# dimensions (XYZC) \n";
    myfile << N << " " << M << " " << P << " " << 1 << " ";
    myfile << "\n\n";
    myfile << "# origin (XYZ) \n";
    myfile << "0.000000 0.000000 0.000000 \n\n";
    myfile << "# resolution (XYZ) \n";
    myfile << "1.000000 1.000000 1.000000 \n\n";
    myfile << "# image coordinates look up table \n";
    myfile.close();

    for(V3DLONG iy = 0; iy < M; iy = iy+Ws-Ws/10)
    {
        V3DLONG yb = iy;
        V3DLONG ye = iy+Ws-1; if(ye>=M-1) ye = M-1;

        for(V3DLONG ix = 0; ix < N; ix = ix+Ws-Ws/10)
        {
            V3DLONG xb = ix;
            V3DLONG xe = ix+Ws-1; if(xe>=N-1) xe = N-1;

            unsigned char *tilearea=0;
            V3DLONG tilepagesz = (xe-xb+1)*(ye-yb+1)*P;
            tilearea = new unsigned char [tilepagesz];
            for(V3DLONG i = 0; i < tilepagesz; i++)
                tilearea[i] = 0;

            V3DLONG tilearea_sz[4];
            tilearea_sz[0] = xe-xb+1; tilearea_sz[1] = ye-yb+1; tilearea_sz[2] = P; tilearea_sz[3] = 1;
            V3DLONG i = 0;

            for(V3DLONG iz = 0; iz < NTILES; iz = iz + 100)
            {
                V3DLONG zb = iz;
                V3DLONG ze = iz + 100 - 1; if(ze>=NTILES-1) ze = NTILES-1;

                QString inputTile(m_OutputfolderName);
                inputTile.append(QString("/x_%1_%2_y_%3_%4_z_%5_%6.raw").arg(xb).arg(xe).arg(yb).arg(ye).arg(zb).arg(ze));

                unsigned char * sub_data1d = 0;
                V3DLONG in_sz_sub[4];
                int datatype;

                if (!simple_loadimage_wrapper(callback,inputTile.toStdString().c_str(), sub_data1d, in_sz_sub, datatype))
                {
                    return;
                }
                V3DLONG inputTilepagesz = in_sz_sub[0]*in_sz_sub[1]*in_sz_sub[2];
                for(V3DLONG j = 0; j < inputTilepagesz; j++)
                {
                    tilearea[i] = sub_data1d[j];
                    i++;
                }
                if(sub_data1d) {delete []sub_data1d; sub_data1d = 0;}
                remove(inputTile.toStdString().c_str());
            }


            QString outputTile(m_OutputfolderName);
            outputTile.append(QString("/x_%1_%2_y_%3_%4.raw").arg(xb).arg(xe).arg(yb).arg(ye));
            simple_saveimage_wrapper(callback, outputTile.toStdString().c_str(), (unsigned char *)tilearea, tilearea_sz, 1);

            myfile.open (tc_name.toStdString().c_str(),ios::out | ios::app );
            QString outputilefull;
            outputilefull.append(QString("x_%1_%2_y_%3_%4.raw").arg(xb).arg(xe).arg(yb).arg(ye));
            outputilefull.append(QString("   ( %1, %2, 0) ( %3, %4, %5)").arg(xb).arg(yb).arg(xe).arg(ye).arg(P-1));
            myfile << outputilefull.toStdString();
            myfile << "\n";
            myfile.close();

            if(tilearea) {delete []tilearea; tilearea =0;}

        }
    }

    myfile.open (tc_name.toStdString().c_str(),ios::out | ios::app );
    myfile << "\n# MST LUT\n";
    myfile.close();

}







































