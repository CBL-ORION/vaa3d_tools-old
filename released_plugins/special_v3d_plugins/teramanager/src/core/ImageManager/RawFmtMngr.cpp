/*
 * This file is a modified version of code extracted from the files stackutil.cpp and
 * stackutil-11.cpp of the V3D project. See the following licence notice for more details.
 *
 * modified by Giulio Iannello, Centro Integrsto di Ricerca, Universita' Campus Bio-Medico di Roma
 * December 2012
 */


/*
 * Copyright (c)2006-2010  Hanchuan Peng (Janelia Farm, Howard Hughes Medical Institute).  
 * All rights reserved.
 */


/************
                                            ********* LICENSE NOTICE ************

This folder contains all source codes for the V3D project, which is subject to the following conditions if you want to use it. 

You will ***have to agree*** the following terms, *before* downloading/using/running/editing/changing any portion of codes in this package.

1. This package is free for non-profit research, but needs a special license for any commercial purpose. Please contact Hanchuan Peng for details.

2. You agree to appropriately cite this work in your related studies and publications.

Peng, H., Ruan, Z., Long, F., Simpson, J.H., and Myers, E.W. (2010) “V3D enables real-time 3D visualization and quantitative analysis of large-scale biological image data sets,” Nature Biotechnology, Vol. 28, No. 4, pp. 348-353, DOI: 10.1038/nbt.1612. ( http://penglab.janelia.org/papersall/docpdf/2010_NBT_V3D.pdf )

Peng, H, Ruan, Z., Atasoy, D., and Sternson, S. (2010) “Automatic reconstruction of 3D neuron structures using a graph-augmented deformable model,” Bioinformatics, Vol. 26, pp. i38-i46, 2010. ( http://penglab.janelia.org/papersall/docpdf/2010_Bioinfo_GD_ISMB2010.pdf )

3. This software is provided by the copyright holders (Hanchuan Peng), Howard Hughes Medical Institute, Janelia Farm Research Campus, and contributors "as is" and any express or implied warranties, including, but not limited to, any implied warranties of merchantability, non-infringement, or fitness for a particular purpose are disclaimed. In no event shall the copyright owner, Howard Hughes Medical Institute, Janelia Farm Research Campus, or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; reasonable royalties; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.

4. Neither the name of the Howard Hughes Medical Institute, Janelia Farm Research Campus, nor Hanchuan Peng, may be used to endorse or promote products derived from this software without specific prior written permission.

*************/




/*
 *  stackutil.cpp
 *
 *
 *  Created (extracted from earlier codes) by Hanchuan Peng on 7/31/06.
 *  Modified on 060803 by Hanchuan Peng: change the size information to be 4 V3DLONG (4-byte) instead of 4-short-int (2byte).
 *  Updated 060806: correct a bug in 4-byte swapping. And notice the compatibility of 32-bit system and 64-bit system about the length of int/V3DLONG types
 *  Copyright 2006 __Hanchuan Peng__. All rights reserved.
 *
 *  060816: add tif support
 *  060828: add surfix extraction function here
 *
 *  060920: add 2-byte formatted raw format support back to increase the compatibility of existing data in the worm project
 *
 *  070214: add two simple interface to read any file formats supported (raw or tif) based on the surfix of filename
 *  070220: add b_VERBOSE_PRINT
 *  070306: add tif file exist verification
 * 070713: George tried to add lsm file reading functions but unsucecssful
 * 070806: Hanchuan added lsm 8-bit reading functions
 * 070807/08: try to handle the imcomplete data generated by the Zeiss lsm writer. The current solution is to change the a function in libtiff tif_lzw.c file
 *            and force it return the value 2, instead of 0, when the input strip size is bigger than real. In this way, the tif function TIFFReadEncodedStrip()
 *            will continue to do postprocessing of the already read data.
 *
 *            Special note: in this way, I will have to build a customary libtiff library and install at my own location ~/work/3rdsoft/lib instead of
 *                          the default /usr/local/lib. When I will have to reset the .bashrc/.profile file and use LD_LIBRARY_PATH (and probably also DYLD_LIBRARY_PATH)
 *                          for Mac to link them. This works for the case of V3D already. However, interestingly, I read an article arguing that using otool/ldd/nm, the dependency
 *                          of objects files can be seen, and that Mac uses the absolute path in library dependency, and that LD_LIBRARY_PATH does not work. The
 *                          interesting thing is that after I tried both, I found otool does show the absolute path, but LD_LIBARY_PATH/DYLD_LIBRARY_PATH works!
 *
 * 070819: add several functions to read LSM file thumbnails and middle slice.
 * 071125: update the copy on my G4 Mac so that it use CPP interface to Gene's codes instead of the C interface
 * 080103: add some further verbose printing
 * 20080213: add interface functions to read single slice of a tiff stack, or the respective thumbnail: Note that the lsm and tif interfaces are DIfferent!
 * 20080301: add handling of 12/16 bit LSM
 * 20080302: change the include "basic_memory.h" to .cpp, due to the template instantiation in V3D
 * 20080401: add the ifndef tag as this will often be included in other files
 * 20080828: add file size limitation, so avoid loading too big file that may cause the tif reader to crash
 * 20080930: return the original tiff pixel value but not the automatically scaled down version
 * 20081204: add overload functions to read only a channel of a stack
 * 20090413: add simple MRC file reading and writing
 * 20090802: add raw5d read/write
 * 20100520: try to revise ZZBIG to allow big file, also add fstat check for windows large file size , instead of using fseek and ftell
 * 20100816: add mylib interface, by PHC.
 * 20110708: fix a memory leak (non-crashing) of redudnant memory allocation of a sz variable
 * 20110804: fix a new Mac fread issue to read more than 2G data in one call (I don't believe I saw this on the old Leopard 64 bit Mac Pro desktop, as we (both Zongcai and I should have) 
 *           benched tested the >3G v3draw file read. This problem is not found for Linux 64bit. Is that a new Mac std libc bug?? 
 *           Anyway, I have now used a 2G buffer to read >2G data. I have not changed the saveStack2Raw functions. It seems they work in the Matlab mex functions. Thus I assumed
 *           they don't need to change. Need tests anyway.
 * 20120410: fix a bug when strcasecmp_l() taking a NULL parameter so that it crashes
 */


// 64-bit and 32-bit checking
// Windows
#if _WIN32 || _WIN64
#if _WIN64
#define ENVIRONMENT64
#else
#define ENVIRONMENT32
#endif
#endif

// GCC
#if __GNUC__
#if __x86_64__ || __ppc64__
#define ENVIRONMENT64
#else
#define ENVIRONMENT32
#endif
#endif

//#include "../elementmexheader.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#include "RawFmtMngr.h"
//#include "basic_memory.cpp" //change basic_memory.h to basic_memory.cpp, 080302

/*
extern "C" {
*/
//#include "mg_image_lib.h"
/*
};
*/

#define b_VERBOSE_PRINT 0
#define ZZBIG 10000 //previous I define it as 1500, so that to limit the size of an image is at most 1.5G //change 2010-05-21 // hang 2011-08-25 6000->10000

#ifdef _MSC_VER       //2010-05-21, by PHC
#include <sys/stat.h>
#include <io.h>
#endif

#define DEFINE_NBYTE2G \
  V3DLONG nBytes2G = (V3DLONG(1024)*V3DLONG(1024)*V3DLONG(1024)-1)*V3DLONG(2);

static char err_message[5000]; // a pointer to this message is returned when there is an exception


/****************************************************
 * AUXILIARY FUNCTIONS
 ****************************************************/

/* function to check endianness of the machine 
 * returns: 
 *  L for little endian machines
 *  B for big endian machines
 *  M for machines that swap 16-bits words
 *  N for unknown endianness
 */
static 
char checkMachineEndian()
{
    char e='N'; //for unknown endianness

    V3DLONG int a=0x44332211;
    unsigned char * p = (unsigned char *)&a;
    if ((*p==0x11) && (*(p+1)==0x22) && (*(p+2)==0x33) && (*(p+3)==0x44))
        e = 'L';
    else if ((*p==0x44) && (*(p+1)==0x33) && (*(p+2)==0x22) && (*(p+3)==0x11))
        e = 'B';
    else if ((*p==0x22) && (*(p+1)==0x11) && (*(p+2)==0x44) && (*(p+3)==0x33))
        e = 'M';
    else
        e = 'N';

    //printf("[%c] \n", e);
    return e;
}


/* functions to swap 2-bytes and 4-bytes words */

static
void swap2bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+1);
    *(tp+1) = a;
}

static
void swap4bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+3);
    *(tp+3) = a;
    a = *(tp+1);
    *(tp+1) = *(tp+2);
    *(tp+2) = a;
}


/****************************************************
 * EXTERNAL FUNCTIONS
 ****************************************************/


char *loadRaw2Metadata ( char * filename, V3DLONG * &sz, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {
    /* This function opens 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters sz, and datatype should be empty, especially the pointer "sz". */

	FILE * fid = fopen(filename, "rb");
	if (!fid)
		return ("Fail to open file for reading");

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	V3DLONG lenkey = strlen(formatkey);

	// for 4 byte integers: datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte
	// WARNINIG: this should still be valid even for 2 byte integres assuming that there are at least 8 data bytes
	if (fileSize<lenkey+2+4*4+1)  
		return ("The size of your input file is too small and is not correct, -- it is too small to contain the legal header");

	char * keyread = new char [lenkey+1];
	if (!keyread)
		return ("Fail to allocate memory");

	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
		return ("File unrecognized or corrupted file");

	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) { /* is non-zero then the two strings are different */
		if (keyread) {delete []keyread; keyread=0;}
		return ("Unrecognized file format");
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		if (keyread) {delete []keyread; keyread=0;}
		return ("This program only supports big- or little- endian but not other format. Check your data endian");
	}

	char endianCodeMachine;
	endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		if (keyread) {delete []keyread; keyread=0;}
		return ("This program only supports big- or little- endian but not other format. Check your data endian");
	}

	b_swap = (endianCodeMachine==endianCodeData)?0:1;

	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			if (keyread) {delete []keyread; keyread=0;}
			return ("Unrecognized data type code. The file type is incorrect or this code is not supported in this version");
	}

	V3DLONG unitSize = datatype; // temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. 

	bool is_4_byte_file = true; // assumes 4 byte file
	V3DLONG totalUnit;
	BIT32_UNIT mysz[4]; // actual buffer 
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;

	// temporary buffer: allocate space for four 4 byte integers
	BIT16_UNIT *sz_2bytes = new BIT16_UNIT[8];

	// try 2 byte integers first
	int tmpn=(int)fread(sz_2bytes, 2, 4, fid); // because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read.
	if (tmpn!=4)
		return ("This program only reads [4] units");
	memcpy(mysz,sz_2bytes,2*4); // save bytes in case it is a 4 byte file
	if (b_swap) {
		for (i=0;i<4;i++) 
			swap2bytes((void *)(sz_2bytes+i));
	}
	totalUnit = 1;
	for (i=0;i<4;i++) {
		totalUnit *= sz_2bytes[i];
	}
	if ((totalUnit*unitSize+4*2+2+1+lenkey) == fileSize) { // 2 byte file
		is_4_byte_file = false;
		// assign sizes to actual buffer
		for (i=0;i<4;i++) {
			mysz[i] = (BIT32_UNIT)sz_2bytes[i];
		}
	}
	delete sz_2bytes;

	if ( is_4_byte_file ) {
		// reads four more 2 byte elements 
		tmpn=(int)fread(mysz+2, 2, 4, fid); // because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. 
		if (tmpn!=4)
			return ("This program only reads [4] units");
		if (b_swap) {
			for (i=0;i<4;i++) 
				swap4bytes((void *)(mysz+i));
		}
		totalUnit = 1;
		for (i=0;i<4;i++) {
			totalUnit *= mysz[i];
		}
		if ((totalUnit*unitSize+4*2+2+1+lenkey) == fileSize) 
			return ("The input file has a size different from what specified in the header");
	}

	//int tmpn=(int)fread(mysz, 4, 4, fid); // because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. 
	//if (tmpn!=4)
	//	return ("This program only reads [4] units");

	//if (b_swap)
	//{
	//	for (i=0;i<4;i++)
	//	{
	//		//swap2bytes((void *)(mysz+i));
	//		swap4bytes((void *)(mysz+i));
	//	}
	//}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; // reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. 
	if (!sz)
	{
		if (keyread) {delete []keyread; keyread=0;}
		return ("Fail to allocate memory");
	}

	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
	}

	// clean and return 
	if (keyread) {delete [] keyread; keyread = 0;}
	//fclose(fid); //bug fix on 060412

	fhandle = fid;
	header_len = ftell(fid);

	return ((char *) 0);
}

void closeRawFile ( void *fhandle ) {
	fclose((FILE *) fhandle);
}

char *loadRaw2SubStack ( void *fhandle, unsigned char *img, V3DLONG *sz, 
						 V3DLONG startx, V3DLONG starty, V3DLONG startz, 
						 V3DLONG endx,V3DLONG endy, V3DLONG endz, 
						 int datatype, int b_swap, int header_len ) //this is the function of 4-byte raw format.
{
	
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameter img should be empty. */
	int i;
	FILE * fid = (FILE *) fhandle;
	
	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);
		
	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
	
	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		totalUnit *= sz[i];
	}	
	
	V3DLONG tmpw = endx - startx;
	V3DLONG tmph = endy - starty;
	V3DLONG tmpz = endz - startz;

	V3DLONG head = header_len; //4*4+2+1+lenkey; // header_len ?
	V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
	V3DLONG cn = tmpw*tmph*tmpz;
	V3DLONG kn = tmpw*tmph;
	V3DLONG total = tmpw*tmph*tmpz*sz[3];

	V3DLONG count=0;
	V3DLONG c,j,k;
	for (c = 0; c < sz[3]; c++)
	{
		for (k = startz; k < endz; k++) 
		{
			for (j = starty; j< endy; j++)
			{
				rewind(fid);
				fseek(fid, head+(c*pgsz1 + k*pgsz2 + j*pgsz3 + startx)*unitSize, SEEK_SET);
				ftell(fid);	
				fread(img+(c*cn+(k-startz)*kn + (j-starty)*tmpw)*unitSize,unitSize,tmpw,fid);
			}
		}
	}

	/* swap the data bytes if necessary */
	
	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<total; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<total; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}

	
	/* clean and return */
	
	return ((char *) 0);
}



char *loadRaw2WholeStack ( char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype) //this is the function of 4-byte raw format.
{
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
		//mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
          sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	/*
#ifdef _MSC_VER
	struct stat stbuf;
	int myfd;
	myfd = open(filename, O_RDONLY);
	if (myfd<0) 
	{
		printf("Fail to use open() for this file. \n");
		berror=1;
		return berror;
	}
	FILE * fid = fdopen(myfd, "rb");
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}
	if (fstat(myfd, &stbuf) == -1)
	{
		printf("Fail to get the file status. \n");
		berror=1;
		return berror;
	}
	V3DLONG fileSize = stbuf.st_size;
#else
*/
	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		return ("Fail to open file for reading");
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);
/*
#endif
*/
	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	V3DLONG lenkey = strlen(formatkey);

#ifndef _MSC_VER //added by PHC, 2010-05-21
	if (fileSize<lenkey+2+4*4+1) // datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. 
	{
		sprintf(err_message,"The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n"
				"The fseek-ftell produces a file size = %ld.", fileSize);
		return err_message;
	}
#endif

	char * keyread = new char [lenkey+1];
	if (!keyread)
		return ("Fail to allocate memory");

	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
		return ("File unrecognized or corrupted file");

	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		if (keyread) {delete []keyread; keyread=0;}
		return ("Unrecognized file format");
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	printf("The data endian code is [%c]\n", endianCodeData);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		if (keyread) {delete []keyread; keyread=0;}
		return ("This program only supports big- or little- endian but not other format. Check your data endian");
	}

	char endianCodeMachine;
	endianCodeMachine = checkMachineEndian();
	printf("The machine endian code is [%c]\n", endianCodeMachine);
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		if (keyread) {delete []keyread; keyread=0;}
		return ("This program only supports big- or little- endian but not other format. Check your data endian");
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			if (keyread) {delete []keyread; keyread=0;}
			return ("Unrecognized data type code. The file type is incorrect or this code is not supported in this version");
	}

	V3DLONG unitSize = datatype; // temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. 

	BIT32_UNIT mysz[4];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=(int)fread(mysz, 4, 4, fid); // because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. 
	if (tmpn!=4)
		return ("This program only reads [4] units");

	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			//swap2bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; // reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. 
	if (!sz)
	{
		if (keyread) {delete []keyread; keyread=0;}
		return ("Fail to allocate memory");
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

#ifndef _MSC_VER //added by PHC, 2010-05-21
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		sprintf(err_message,"The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n"
				"The read sizes are: %ld %ld %ld %ld\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey, sz[0], sz[1], sz[2], sz[3]);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		return err_message;
	}
#endif

	if (img) {delete []img; img=0;}
	V3DLONG totalBytes = V3DLONG(unitSize)*V3DLONG(totalUnit);
	try 
	{
		img = new unsigned char [totalBytes];
	}
	catch (...)
	{
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		return ("Fail to allocate memory in loadRaw2Stack()");
	}

	V3DLONG remainingBytes = totalBytes;
    
    DEFINE_NBYTE2G
	
	V3DLONG cntBuf = 0;
	while (remainingBytes>0)
	{
		V3DLONG curReadBytes = (remainingBytes<nBytes2G) ? remainingBytes : nBytes2G;
		V3DLONG curReadUnits = curReadBytes/unitSize;
		nread = fread(img+cntBuf*nBytes2G, unitSize, curReadUnits, fid);
		if (nread!=curReadUnits)
		{
			sprintf(err_message,"Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points]", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			return err_message;
		}
		
		remainingBytes -= nBytes2G;
		cntBuf++;
	}

	// swap the data bytes if necessary 

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}

	// clean and return 

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	//a debug check of the min max value
	//double minvv=10000, maxvv=-1;
	//for (V3DLONG myii=0; myii<sz[0]*sz[1]*sz[2];myii++)
	//{
	//	if (minvv>img[myii]) minvv=img[myii];
	//	else if (maxvv<img[myii]) maxvv=img[myii];
	//}
	//printf("*** for loadRaw2Stack() all readin bytes: minvv=%5.3f maxvv=%5.3f\n", minvv, maxvv);	
	
	return ((char *) 0);
}



